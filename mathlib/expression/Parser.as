package mathlib.expression {	import mathlib.expression.datatype.Token;	import mathlib.expression.datatype.TokenType;	import mathlib.expression.datatype.ParseTree;		public class Parser {		private static var tokens:Array;				public static function parse(_tokens:Array):ParseTree {			var pt:ParseTree;			// make a local copy of the token array			tokens = _tokens.concat();			// try to parse it as an expression			pt = parseE();			// if we didn't consume all the tokens, something's amiss			if(tokens.length != 0)				throw new SyntaxError("unexpected token(s) after end of expression: " + tokens.toString());			return pt;		}				private static function parseE():ParseTree {			var eparse:ParseTree, temppt:ParseTree;						// first, parse a term			eparse = parseTM();						// then, while we have an addop, make a new parent branch for the stuff we just parsed,			// and tack things on the top as appropriate.			// this way, we get left-association for addition, so things like 1-2+3 get parsed as			//     +			//    / \			//   -   3			//  / \			// 1   2			while(tokens.length != 0 && tokens[0].type == TokenType.ADDOP) {				temppt = eparse;				eparse = new ParseTree(tokens.shift(), false);  // the false specifies that the node will definitely have children				eparse.appendChild(temppt);				eparse.appendChild(parseTM());			}						return eparse;		}				private static function parseTM():ParseTree {			var tmparse:ParseTree, temppt:ParseTree;						// parse a factor.			tmparse = parseF();						// same left-association deal as with parseE			while(tokens.length != 0 && tokens[0].type == TokenType.MULOP) {				temppt = tmparse;				tmparse = new ParseTree(tokens.shift(), false);				tmparse.appendChild(temppt);				tmparse.appendChild(parseF());			}			return tmparse;		}						private static function parseF():ParseTree {			var fparse:ParseTree, temppt:ParseTree;						if(tokens.length == 0)				throw new SyntaxError("expected a factor");						// F => -F production			if(tokens[0].type == TokenType.NEGATE) {				fparse = new ParseTree(tokens.shift());				fparse.appendChild(parseF());			}			else {				// F => DAT production				fparse = parseDAT();								// exponentiation associates to the right, we tack further exponentiations				// to the bottom of the root node, unlike addition and multiplication in parseE and parseTM				if(tokens.length != 0 && tokens[0].type == TokenType.POW) {					temppt = fparse;					fparse = new ParseTree(tokens.shift());					fparse.appendChild(temppt);					fparse.appendChild(parseF());				}			}						return fparse;		}				private static function parseFN():ParseTree {			var head:Token, arity:int, i:int, fnparse:ParseTree;						// first, grab a function from the token stream and make a tree			// with it as its root.			head = eatMandToken(TokenType.FN);			arity = head.val.length;  // little known fact: a Function's length is its arity			fnparse = new ParseTree(head);							// then a (			eatMandToken(TokenType.LP, "Functions must be followed with by an opening parenthesis.");						if(arity > 0) {				// parse one argument				fnparse.appendChild(parseE());							// then a comma, then the next, and so on, until we've hit the arity of the function				for(i = 1; i < arity; i++) {					eatMandToken(TokenType.COMMA, "Too few arguments to a function?");					fnparse.appendChild(parseE());				}			}						eatMandToken(TokenType.RP, "Too many arguments to a function?");						return fnparse;		}										private static function parseDAT():ParseTree {			var eparse:ParseTree;						if(tokens.length == 0)				throw new SyntaxError("expected a datum");						switch(tokens[0].type) {				case TokenType.VAR:				case TokenType.NUM:				case TokenType.CONST:					return new ParseTree(tokens.shift());									case TokenType.FN:					return parseFN();								case TokenType.LP:					tokens.shift();					eparse = parseE();					eatMandToken(TokenType.RP, "Mismatched parentheses.");					return eparse;									default:					throw new SyntaxError("expected a datum");			}		}				// Return the head token if it matches the expected type, otherwise throw an error.		private static function eatMandToken(type:TokenType, hint:String = ""):Token {			var errStr:String;						if(tokens.length == 0 || tokens[0].type != type) {				errStr = "expected " + type.toString();				if(hint) errStr += "\n" + hint;				throw new SyntaxError(errStr);			}						return tokens.shift();		}	}}