package mathlib.expression {	import mathlib.expression.datatype.TokenType;	import mathlib.expression.datatype.ParseTree;	public class Compiler {		public var env:Environment;		public var optimize:Boolean = true;				public function Compiler(... args):void {			if(args.length == 0)				env = new Environment();			else if(args.length > 1)				env = new Environment(args);			else if(args[0] is Environment)				env = args[0];			else if(args[0] is Array || args[0] is String)				env = new Environment(args[0]);			else				throw new ArgumentError("expected an Environment, a list or array of variable names, or no argument");		}				public function compile(s:String):CompiledFn {			return compileTokenArray(Lexer.lex(env, s));		}				public function compileTokenArray(tokens:Array):CompiledFn {			return compileParseTree(Parser.parse(tokens));		}				public function compileParseTree(pt:ParseTree):CompiledFn {			var prefix:Array = new Array();			if(optimize)				optPtToArrayAcc(prefix, pt);			else				ptToArrayAcc(prefix, pt);			return new CompiledFn(prefix, env);		}						// optimizing traversal detects constant subtrees and replaces them		// with their value		private function optPtToArrayAcc(arr:Array, pt:ParseTree):void {			var child:ParseTree;			var tempCFn:CompiledFn;			var tempPrefix:Array;						if(pt.isLeaf)				arr.push(pt.token.val);						else if(isConstantTree(pt)) {				tempPrefix = new Array();								// we call the non-optimizing version to naively traverse the				// constant subtree and avoid an infinite regress				ptToArrayAcc(tempPrefix, pt);				tempCFn = new CompiledFn(tempPrefix, env);								// since we are guaranteed there are no variables in this				// subtree, we call evalAsIs, which doesn't make us give it				// values for the variables.  the Number result is added to the				// prefix array in place of the subtree.				arr.push(tempCFn.evalAsIs());			}						else {				arr.push(pt.token.val);				for each(child in pt.children)					optPtToArrayAcc(arr, child);			}		}						// standard prefix traversal, non-optimizing		private function ptToArrayAcc(arr:Array, pt:ParseTree):void {			var child:ParseTree;						arr.push(pt.token.val);			if(!pt.isLeaf) {				for each(child in pt.children)					ptToArrayAcc(arr, child);			}		}				private function isConstantTree(pt:ParseTree):Boolean {			return pt.token.type != TokenType.VAR && 			       (pt.isLeaf || areConstantTrees(pt.children));		}				// an empty array is considered constant		private function areConstantTrees(pts:Array):Boolean {			var pt:ParseTree;						for each(pt in pts)				if(!isConstantTree(pt)) return false;			return true;		}	}}