package mathlib.expression {	import flash.utils.Dictionary;	import mathlib.expression.datatype.IndVar;		public class Environment {		public var fns:Dictionary = new Dictionary();		public var consts:Dictionary = new Dictionary();		public var addops:Dictionary = new Dictionary();		public var mulops:Dictionary = new Dictionary();		public var vars:Dictionary = new Dictionary();		public var varCount:int;		public var doImplicitMult:Boolean = true;		public var implicitMulOp:Function;		public var negate:Function;		public var subtract:Function;		public var pow:Function;				// the constructor accepts no args, or an array or a list which are passed 		// to addVars, which will throw an error if necessary.		public function Environment(... args):void {			varCount = 0;						if(args.length == 1 && args[0] is Array)				addVars(args[0]);			else if(args.length > 0)				addVars(args);							// trig				fns["sin"] = Math.sin;			fns["cos"] = Math.cos;			fns["tan"] = Math.tan;			fns["asin"] = Math.asin;			fns["arcsin"] = Math.asin;			fns["acos"] = Math.acos;			fns["arccos"] = Math.acos;			fns["atan"] = Math.atan;			fns["arctan"] = Math.atan;			fns["atan2"] = Math.atan2;			fns["arctan2"] = Math.atan2;						// exponentiation, etc.			fns["exp"] = Math.exp;			fns["sqrt"] = Math.sqrt;			fns["pow"] = Math.pow;			fns["log"] = Math.log;			fns["ln"] = Math.log;			fns["log10"] = log10;			fns["log2"] = log2;			// miscellaneous			fns["max"] = Math.max;			fns["min"] = Math.min;			fns["abs"] = Math.abs;			fns["floor"] = Math.floor;			fns["ceil"] = Math.ceil;			fns["round"] = Math.round;			fns["random"] = Math.random;			fns["rnd"] = Math.random;			fns["rand"] = Math.random;			fns["mod"] = mod;						// operators			addops["-"] = subtractfn;			addops["+"] = add;			mulops["*"] = mult;			mulops["/"] = div;			// constants					consts["e"] = Math.E;			consts["ln10"] = Math.LN10;			consts["ln2"] = Math.LN2;			consts["log10e"] = Math.LOG10E;			consts["log2e"] = Math.LOG2E;			consts["pi"] = Math.PI;			consts["sqrt1_2"] = Math.SQRT1_2;			consts["sqrt2"] = Math.SQRT2;						// important things to the parser & lexer			subtract = subtractfn;			negate = negatefn;			pow = Math.pow;			implicitMulOp = mult;		}				public function addVars(varNames:Array):void {			var v:IndVar;			var i:int;						for(i = 0; i < varNames.length; i++) {				if(!isValidVarName(varNames[i]))					throw new SyntaxError("invalid variable name: " + varNames[i].toString());				if(isKnownId(varNames[i]))					throw new Error("variable name " + varNames[i].toString() + "conflicts with another identifier"); 								v = new IndVar(varCount);				vars[varNames[i]] = v;				vars[varCount] = v;								varCount++;			}		}				public function isKnownId(id:String):Boolean {			return fns[id] != undefined    ||			       addops[id] != undefined ||				   mulops[id] != undefined || 				   consts[id] != undefined ||				   vars[id] != undefined;		}				private function isValidVarName(varName:*):Boolean {			var r:RegExp = /^[A-Za-z_][A-Za-z_0-9]*$/;						return (varName is String) && r.test(varName);		}		private function negatefn(x: Number):Number { return -x; }		private function subtractfn(x:Number, y:Number):Number { return x - y; }		private function add(x:Number, y:Number):Number { return x + y; }		private function mult(x:Number, y:Number):Number { return x * y; }		private function div(x:Number, y:Number):Number { return x / y; }		private function mod(x:Number, m:Number):Number { return x % m; }		private function log10(x:Number):Number { return Math.log(x) / Math.LN10; }		private function log2(x:Number):Number { return Math.log(x) / Math.LN2; }	}}