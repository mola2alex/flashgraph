package mathlib.expression {	import flash.utils.Dictionary;	import mathlib.expression.datatype.Token;	import mathlib.expression.datatype.TokenType;		public class Lexer {		private static var env:Environment;		private static var tokens:Array;		private static var s:String;		private static var idRegex:RegExp = /^([A-Za-z_][A-Za-z_0-9]*)(.*)/s;		private static var numRegex:RegExp = /^([0-9]*\.?[0-9]+)(.*)/s;		private static var alphaRegex:RegExp = /^[A-Za-z_]/;		private static var simplenumRegex:RegExp = /^[0-9.]/;				// public wrapper for realLex that returns the token array		public static function lex(_env:Environment, _s:String):Array {			env = _env;			s = eatSpaces(_s);			tokens = new Array();						while(s.length > 0)				realLex();						return tokens;		}				// the real lexer.  consumes one token from s and appends its result to tokens.		private static function realLex():void {			if(s.length == 0) return;						switch(s.charAt(0)) {				case "(":					addImplicitMult();					pushNewToken(TokenType.LP);					s = s.substring(1);					return;									case ")":					pushNewToken(TokenType.RP);					s = s.substring(1);					return;								case ",":					pushNewToken(TokenType.COMMA);					s = s.substring(1);					return;								case "-":					lexMinus();					return;			}						if(idRegex.test(s))				lexId();					// the minus lexer considers negative numbers to be applications of the negate operator.			// the compiler optimizes these back to normal numbers if possible.			else if(simplenumRegex.test(s))				lexNum();						// this could use cleanup: throw/catch is not for flow control.			else {				try {					lexOp();				} catch(err:SyntaxError) {					throw new SyntaxError("invalid input: " + s);				}			}		}						private static function pushNewToken(_type:TokenType, _val:* = undefined):void {			tokens.push(new Token(_type, _val));		}				// add in a multiplication token if appropriate.		// if numOK is true, we insert the multiplication if the previous token was a number.		// this is a problem only when we have two numbers side by side -- this is a parse		// error, and adding a multiplication between them would hide that fact.  e.g.,		// since space is insignificant, it would let input like "0.2341.242" slide as 0.2341 * 0.242.		// "sin(x)" is distinguished from "x(2)" by not inserting a multiplication if the previous		// token was a function. 		private static function addImplicitMult(numOK:Boolean = true):void {			if(!env.doImplicitMult || tokens.length == 0) return;						var lastType:TokenType = tokens[tokens.length - 1].type;					if(lastType == TokenType.RP    ||			// ...)x --> ...) * x			   lastType == TokenType.VAR   ||			// xy    --> x * y			   lastType == TokenType.CONST ||			// pix   --> pi * x			   (numOK && lastType == TokenType.NUM))	// 2x    --> 2 * x				pushNewToken(TokenType.MULOP, env.implicitMulOp)		}				private static function eatSpaces(str:String):String {			return str.replace(/\s/g, "");		}				private static function lexNum():void {			// an optional number of digits, a possible period, then more digits (at least one).			// we match everything thereafter to pass on in the state.			// negative numbers are lexed as an application of the negate operator.			var res:Object = numRegex.exec(s);					if(res == null)	throw new SyntaxError("expected a number");					// apropos the false, see the discussion at addImplicitMult			addImplicitMult(false);			pushNewToken(TokenType.NUM, parseFloat(res[1]));			s = res[2];		}				private static function lexId():void {			// an ID is something that could be a variable, a function name, or a constant			// it begins with a letter or underscore and continues with any alphanumerics			// there are obviously semantic implications of what type of ID this is found to be...			// e.g.: a function must be followed by a parenthesis, but that's for the parser to deal with			var tok:Token;			var id:String, newS:String;			var res:Object = idRegex.exec(s);						if(res == null)	throw new SyntaxError("expected an identifier");						id = res[1];			newS = res[2];						tok = idToToken(id);						// if we're not doing implicit multiplication, the whole regexp			// match is our only option			if(tok != null)	{				addImplicitMult();				tokens.push(tok);				s = newS;				return;			}			// otherwise, keep paring off one letter at time from the right			// of the id until we hit something we know about			else if(env.doImplicitMult && id.length > 1) {				while(id.length > 1) {					newS = id.charAt(id.length - 1) + newS;					id = id.substr(0, id.length - 1);										tok = idToToken(id);					if(tok != null) {						addImplicitMult();						tokens.push(tok);						s = newS;						return;					}				}			}						throw new SyntaxError("unknown identifier " + id);		}												// look up an ID string in the environment and convert it to the 		// appropriate token type.  return null if no match.		private static function idToToken(id:String):Token {			var tok:Token;						if(env.fns[id] != undefined)				tok = new Token(TokenType.FN, env.fns[id]);			else if(env.consts[id] != undefined)				tok = new Token(TokenType.CONST, env.consts[id]);			else if(env.vars[id] != undefined)				tok = new Token(TokenType.VAR, env.vars[id]);						return tok;		}				private static function lexMinus():void {			if(s.charAt(0) != "-")				throw new SyntaxError("expected a minus");						if(shouldNegate()) {				pushNewToken(TokenType.NEGATE, env.negate);				s = s.substring(1);			}			else {				pushNewToken(TokenType.ADDOP, env.subtract);				s = s.substring(1);			}		}				// a minus needs special treatment, depending on what token preceded it:		//		{empty, "(", op, ",", "^", negate} - *	--> negate		//		anything else - * 						--> subtract		private static function shouldNegate():Boolean {			var last:Token;			if(tokens.length == 0)				return true;			last = tokens[tokens.length - 1];			return last.type == TokenType.LP    ||				   last.type == TokenType.ADDOP ||				   last.type == TokenType.MULOP ||				   last.type == TokenType.COMMA ||				   last.type == TokenType.POW   ||				   last.type == TokenType.NEGATE;		}				private static function lexOp():void {			var c:String = s.charAt(0);						if(env.addops[c] != undefined)				pushNewToken(TokenType.ADDOP, env.addops[c]);			else if(env.mulops[c] != undefined)				pushNewToken(TokenType.MULOP, env.mulops[c]);			else if(c == "^")				pushNewToken(TokenType.POW, env.pow);			else				throw new Error("expected an operator");						s = s.substring(1);		}			}}